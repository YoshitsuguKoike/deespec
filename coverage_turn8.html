
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>execution: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/YoshitsuguKoike/deespec/internal/domain/execution/decision.go (100.0%)</option>
				
				<option value="file1">github.com/YoshitsuguKoike/deespec/internal/domain/execution/entity.go (97.9%)</option>
				
				<option value="file2">github.com/YoshitsuguKoike/deespec/internal/domain/execution/error.go (100.0%)</option>
				
				<option value="file3">github.com/YoshitsuguKoike/deespec/internal/domain/execution/execution_status.go (100.0%)</option>
				
				<option value="file4">github.com/YoshitsuguKoike/deespec/internal/domain/execution/execution_step.go (100.0%)</option>
				
				<option value="file5">github.com/YoshitsuguKoike/deespec/internal/domain/execution/service.go (88.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package execution

import "strings"

// Decision represents the review decision
type Decision string

const (
        DecisionPending      Decision = "PENDING"       // Not yet decided
        DecisionNeedsChanges Decision = "NEEDS_CHANGES" // Needs changes, retry
        DecisionSucceeded    Decision = "SUCCEEDED"     // Final success status
        DecisionFailed       Decision = "FAILED"        // Final failure status
)

// String returns the string representation of the decision
func (d Decision) String() string <span class="cov8" title="1">{
        return string(d)
}</span>

// IsValid returns true if the decision is valid
func (d Decision) IsValid() bool <span class="cov8" title="1">{
        switch d </span>{
        case DecisionPending, DecisionNeedsChanges, DecisionSucceeded, DecisionFailed:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// IsFinal returns true if this is a final decision (succeeded/failed)
func (d Decision) IsFinal() bool <span class="cov8" title="1">{
        return d == DecisionSucceeded || d == DecisionFailed
}</span>

// IsApproved returns true if the decision is approved (SUCCEEDED)
func (d Decision) IsApproved() bool <span class="cov8" title="1">{
        return d == DecisionSucceeded
}</span>

// RequiresRetry returns true if the decision requires retry
func (d Decision) RequiresRetry() bool <span class="cov8" title="1">{
        return d == DecisionNeedsChanges
}</span>

// IsPending returns true if the decision is pending
func (d Decision) IsPending() bool <span class="cov8" title="1">{
        return d == DecisionPending
}</span>

// ParseDecision parses a string into a Decision
func ParseDecision(s string) Decision <span class="cov8" title="1">{
        normalized := strings.ToUpper(strings.TrimSpace(s))

        switch normalized </span>{
        case "OK", "APPROVED", "PASS", "PASSED", "SUCCEEDED", "SUCCESS":<span class="cov8" title="1">
                return DecisionSucceeded</span>
        case "NEEDS_CHANGES", "NEEDS CHANGES", "FAIL", "REJECT", "REJECTED":<span class="cov8" title="1">
                return DecisionNeedsChanges</span>
        case "FAILED", "FAILURE":<span class="cov8" title="1">
                return DecisionFailed</span>
        case "PENDING", "":<span class="cov8" title="1">
                return DecisionPending</span>
        default:<span class="cov8" title="1">
                // Default to needs changes for unknown values
                return DecisionNeedsChanges</span>
        }
}

// ToJournalDecision converts to the journal format decision
func (d Decision) ToJournalDecision() string <span class="cov8" title="1">{
        switch d </span>{
        case DecisionSucceeded:<span class="cov8" title="1">
                return "OK"</span>
        case DecisionNeedsChanges, DecisionFailed:<span class="cov8" title="1">
                return "NEEDS_CHANGES"</span>
        case DecisionPending:<span class="cov8" title="1">
                return "PENDING"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// CanTransitionTo checks if transition to another decision is allowed
func (d Decision) CanTransitionTo(next Decision) bool <span class="cov8" title="1">{
        // From pending, can go to other decisions
        if d == DecisionPending </span><span class="cov8" title="1">{
                return next == DecisionNeedsChanges || next == DecisionSucceeded || next == DecisionFailed
        }</span>

        // From needs changes, can go to succeeded or failed
        <span class="cov8" title="1">if d == DecisionNeedsChanges </span><span class="cov8" title="1">{
                return next == DecisionSucceeded || next == DecisionFailed || next == DecisionPending
        }</span>

        // Final decisions cannot transition
        <span class="cov8" title="1">if d.IsFinal() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package execution

import (
        "fmt"
        "time"
)

// SBIExecution represents the execution state of an SBI task
type SBIExecution struct {
        ID          ExecutionID
        SBIID       string
        Step        ExecutionStep
        Status      ExecutionStatus
        Decision    Decision
        Attempt     int // Number of implementation attempts (1-3)
        StartedAt   time.Time
        UpdatedAt   time.Time
        CompletedAt *time.Time
}

// ExecutionID is a value object for execution identifier
type ExecutionID string

// NewExecutionID creates a new ExecutionID
func NewExecutionID(sbiID string, startedAt time.Time) ExecutionID <span class="cov8" title="1">{
        return ExecutionID(fmt.Sprintf("%s_%d", sbiID, startedAt.Unix()))
}</span>

// NewSBIExecution creates a new SBI execution
func NewSBIExecution(sbiID string) *SBIExecution <span class="cov8" title="1">{
        now := time.Now()
        return &amp;SBIExecution{
                ID:        NewExecutionID(sbiID, now),
                SBIID:     sbiID,
                Step:      StepReady,
                Status:    StatusReady,
                Decision:  DecisionPending,
                Attempt:   0,
                StartedAt: now,
                UpdatedAt: now,
        }
}</span>

// TransitionTo transitions the execution to the next step based on current state and decision
func (e *SBIExecution) TransitionTo(nextStep ExecutionStep) error <span class="cov8" title="1">{
        // Validate transition
        if !e.Step.CanTransitionTo(nextStep) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid transition from %s to %s", e.Step, nextStep)
        }</span>

        // Handle attempt counter for implementation steps (before updating step)
        <span class="cov8" title="1">if nextStep.IsImplementation() </span><span class="cov8" title="1">{
                e.Attempt++
        }</span>

        // Update step and related fields
        <span class="cov8" title="1">e.Step = nextStep
        e.Status = nextStep.ToStatus()
        e.UpdatedAt = time.Now()

        // Mark as completed if done
        if nextStep == StepDone </span><span class="cov8" title="1">{
                now := time.Now()
                e.CompletedAt = &amp;now
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ApplyDecision applies a review decision to the execution
func (e *SBIExecution) ApplyDecision(decision Decision) error <span class="cov8" title="1">{
        if !e.Status.IsReview() </span><span class="cov8" title="1">{
                return fmt.Errorf("can only apply decision in review status, current: %s", e.Status)
        }</span>

        <span class="cov8" title="1">if !decision.IsValid() </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid decision: %s", decision)
        }</span>

        <span class="cov8" title="1">e.Decision = decision
        e.UpdatedAt = time.Now()
        return nil</span>
}

// IsCompleted returns true if the execution is completed
func (e *SBIExecution) IsCompleted() bool <span class="cov8" title="1">{
        return e.Step == StepDone
}</span>

// ShouldForceTerminate returns true if the execution should be forcefully terminated
func (e *SBIExecution) ShouldForceTerminate() bool <span class="cov8" title="1">{
        // Force terminate after 3 failed attempts
        return e.Attempt &gt;= 3 &amp;&amp; e.Decision == DecisionNeedsChanges
}</span>

// NextStep determines the next step based on current state and decision
func (e *SBIExecution) NextStep() (ExecutionStep, error) <span class="cov8" title="1">{
        switch e.Step </span>{
        case StepReady:<span class="cov8" title="1">
                return StepImplementTry, nil</span>

        case StepImplementTry:<span class="cov8" title="1">
                return StepFirstReview, nil</span>

        case StepFirstReview:<span class="cov8" title="1">
                if e.Decision == DecisionSucceeded </span><span class="cov8" title="1">{
                        return StepDone, nil
                }</span>
                <span class="cov8" title="1">return StepImplementSecondTry, nil</span>

        case StepImplementSecondTry:<span class="cov8" title="1">
                return StepSecondReview, nil</span>

        case StepSecondReview:<span class="cov8" title="1">
                if e.Decision == DecisionSucceeded </span><span class="cov8" title="1">{
                        return StepDone, nil
                }</span>
                <span class="cov8" title="1">return StepImplementThirdTry, nil</span>

        case StepImplementThirdTry:<span class="cov0" title="0">
                return StepThirdReview, nil</span>

        case StepThirdReview:<span class="cov8" title="1">
                if e.Decision == DecisionSucceeded </span><span class="cov8" title="1">{
                        return StepDone, nil
                }</span>
                // Force termination path
                <span class="cov8" title="1">return StepReviewerForceImplement, nil</span>

        case StepReviewerForceImplement:<span class="cov8" title="1">
                return StepImplementerReview, nil</span>

        case StepImplementerReview:<span class="cov8" title="1">
                return StepDone, nil</span>

        case StepDone:<span class="cov8" title="1">
                return StepDone, nil</span> // No transition from done

        default:<span class="cov8" title="1">
                return "", fmt.Errorf("unknown step: %s", e.Step)</span>
        }
}

// GetFinalDecision returns the final decision for completed executions
func (e *SBIExecution) GetFinalDecision() Decision <span class="cov8" title="1">{
        if !e.IsCompleted() </span><span class="cov8" title="1">{
                return DecisionPending
        }</span>

        // Return the actual decision if it's final
        <span class="cov8" title="1">if e.Decision.IsFinal() </span><span class="cov8" title="1">{
                return e.Decision
        }</span>

        // If went through force termination, it's failed
        <span class="cov8" title="1">if e.Step == StepDone &amp;&amp; e.Attempt &gt;= 3 </span><span class="cov8" title="1">{
                return DecisionFailed
        }</span>

        <span class="cov8" title="1">return e.Decision</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package execution

import "fmt"

// ExecutionError represents domain-specific errors for execution
type ExecutionError struct {
        Code    string
        Message string
        Details map[string]interface{}
}

// Error implements the error interface
func (e ExecutionError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}</span>

// Common execution errors
var (
        // ErrExecutionNotFound indicates the execution was not found
        ErrExecutionNotFound = ExecutionError{
                Code:    "EXEC_NOT_FOUND",
                Message: "Execution not found",
        }

        // ErrExecutionAlreadyExists indicates an execution already exists for the SBI
        ErrExecutionAlreadyExists = ExecutionError{
                Code:    "EXEC_ALREADY_EXISTS",
                Message: "An active execution already exists for this SBI",
        }

        // ErrInvalidTransition indicates an invalid state transition
        ErrInvalidTransition = ExecutionError{
                Code:    "EXEC_INVALID_TRANSITION",
                Message: "Invalid state transition",
        }

        // ErrExecutionCompleted indicates operation on completed execution
        ErrExecutionCompleted = ExecutionError{
                Code:    "EXEC_ALREADY_COMPLETED",
                Message: "Execution is already completed",
        }

        // ErrMaxAttemptsReached indicates maximum attempts have been reached
        ErrMaxAttemptsReached = ExecutionError{
                Code:    "EXEC_MAX_ATTEMPTS",
                Message: "Maximum implementation attempts reached",
        }

        // ErrInvalidDecision indicates an invalid decision value
        ErrInvalidDecision = ExecutionError{
                Code:    "EXEC_INVALID_DECISION",
                Message: "Invalid decision value",
        }

        // ErrExecutionStuck indicates the execution is stuck
        ErrExecutionStuck = ExecutionError{
                Code:    "EXEC_STUCK",
                Message: "Execution is stuck and requires intervention",
        }
)

// NewExecutionError creates a new execution error with details
func NewExecutionError(code, message string, details map[string]interface{}) ExecutionError <span class="cov8" title="1">{
        return ExecutionError{
                Code:    code,
                Message: message,
                Details: details,
        }
}</span>

// WithDetails adds details to an existing error
func (e ExecutionError) WithDetails(details map[string]interface{}) ExecutionError <span class="cov8" title="1">{
        e.Details = details
        return e
}</span>

// IsNotFound checks if the error is a not found error
func IsNotFound(err error) bool <span class="cov8" title="1">{
        execErr, ok := err.(ExecutionError)
        return ok &amp;&amp; execErr.Code == ErrExecutionNotFound.Code
}</span>

// IsAlreadyExists checks if the error is an already exists error
func IsAlreadyExists(err error) bool <span class="cov8" title="1">{
        execErr, ok := err.(ExecutionError)
        return ok &amp;&amp; execErr.Code == ErrExecutionAlreadyExists.Code
}</span>

// IsCompleted checks if the error is a completed execution error
func IsCompleted(err error) bool <span class="cov8" title="1">{
        execErr, ok := err.(ExecutionError)
        return ok &amp;&amp; execErr.Code == ErrExecutionCompleted.Code
}</span>

// IsMaxAttempts checks if the error is a max attempts error
func IsMaxAttempts(err error) bool <span class="cov8" title="1">{
        execErr, ok := err.(ExecutionError)
        return ok &amp;&amp; execErr.Code == ErrMaxAttemptsReached.Code
}</span>

// IsInvalidTransition checks if the error is an invalid transition error
func IsInvalidTransition(err error) bool <span class="cov8" title="1">{
        execErr, ok := err.(ExecutionError)
        return ok &amp;&amp; execErr.Code == ErrInvalidTransition.Code
}</span>

// IsInvalidDecision checks if the error is an invalid decision error
func IsInvalidDecision(err error) bool <span class="cov8" title="1">{
        execErr, ok := err.(ExecutionError)
        return ok &amp;&amp; execErr.Code == ErrInvalidDecision.Code
}</span>

// IsExecutionStuck checks if the error is an execution stuck error
func IsExecutionStuck(err error) bool <span class="cov8" title="1">{
        execErr, ok := err.(ExecutionError)
        return ok &amp;&amp; execErr.Code == ErrExecutionStuck.Code
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package execution

// ExecutionStatus represents the high-level status of the execution
type ExecutionStatus string

const (
        StatusReady        ExecutionStatus = "READY"      // Ready to start
        StatusWIP          ExecutionStatus = "WIP"        // Work In Progress (implementation)
        StatusReview       ExecutionStatus = "REVIEW"     // Under review
        StatusReviewAndWIP ExecutionStatus = "REVIEW&amp;WIP" // Special dual status for forced implementation
        StatusDone         ExecutionStatus = "DONE"       // Completed
        StatusUnknown      ExecutionStatus = "UNKNOWN"    // Unknown status
)

// String returns the string representation of the status
func (s ExecutionStatus) String() string <span class="cov8" title="1">{
        return string(s)
}</span>

// IsActive returns true if the execution is still active (not done)
func (s ExecutionStatus) IsActive() bool <span class="cov8" title="1">{
        return s != StatusDone &amp;&amp; s != StatusUnknown
}</span>

// IsWIP returns true if the status indicates work in progress
func (s ExecutionStatus) IsWIP() bool <span class="cov8" title="1">{
        return s == StatusWIP || s == StatusReviewAndWIP
}</span>

// IsReview returns true if the status indicates review phase
func (s ExecutionStatus) IsReview() bool <span class="cov8" title="1">{
        return s == StatusReview || s == StatusReviewAndWIP
}</span>

// IsReady returns true if the status is ready
func (s ExecutionStatus) IsReady() bool <span class="cov8" title="1">{
        return s == StatusReady
}</span>

// IsDone returns true if the status is done
func (s ExecutionStatus) IsDone() bool <span class="cov8" title="1">{
        return s == StatusDone
}</span>

// IsValid returns true if the status is valid
func (s ExecutionStatus) IsValid() bool <span class="cov8" title="1">{
        switch s </span>{
        case StatusReady, StatusWIP, StatusReview, StatusReviewAndWIP, StatusDone:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// CanTransitionTo checks if transition to another status is allowed
func (s ExecutionStatus) CanTransitionTo(next ExecutionStatus) bool <span class="cov8" title="1">{
        validTransitions := map[ExecutionStatus][]ExecutionStatus{
                StatusReady:        {StatusWIP},
                StatusWIP:          {StatusReview},
                StatusReview:       {StatusWIP, StatusDone, StatusReviewAndWIP},
                StatusReviewAndWIP: {StatusReview},
                StatusDone:         {}, // No transitions from done
        }

        allowed, exists := validTransitions[s]
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, validNext := range allowed </span><span class="cov8" title="1">{
                if validNext == next </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// Priority returns the priority of the status for sorting
func (s ExecutionStatus) Priority() int <span class="cov8" title="1">{
        switch s </span>{
        case StatusReviewAndWIP:<span class="cov8" title="1">
                return 1</span> // Highest priority - critical state
        case StatusReview:<span class="cov8" title="1">
                return 2</span>
        case StatusWIP:<span class="cov8" title="1">
                return 3</span>
        case StatusReady:<span class="cov8" title="1">
                return 4</span>
        case StatusDone:<span class="cov8" title="1">
                return 5</span>
        default:<span class="cov8" title="1">
                return 99</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package execution

// ExecutionStep represents the detailed step in the execution flow (1-10)
type ExecutionStep string

const (
        StepReady                  ExecutionStep = "ready"                    // Step 1
        StepImplementTry           ExecutionStep = "implement_try"            // Step 2
        StepFirstReview            ExecutionStep = "first_review"             // Step 3
        StepImplementSecondTry     ExecutionStep = "implement_second_try"     // Step 4
        StepSecondReview           ExecutionStep = "second_review"            // Step 5
        StepImplementThirdTry      ExecutionStep = "implement_third_try"      // Step 6
        StepThirdReview            ExecutionStep = "third_review"             // Step 7
        StepReviewerForceImplement ExecutionStep = "reviewer_force_implement" // Step 8
        StepImplementerReview      ExecutionStep = "implementer_review"       // Step 9
        StepDone                   ExecutionStep = "done"                     // Step 10
)

// String returns the string representation of the step
func (s ExecutionStep) String() string <span class="cov8" title="1">{
        return string(s)
}</span>

// ToNumber returns the numeric representation of the step (1-10)
func (s ExecutionStep) ToNumber() int <span class="cov8" title="1">{
        switch s </span>{
        case StepReady:<span class="cov8" title="1">
                return 1</span>
        case StepImplementTry:<span class="cov8" title="1">
                return 2</span>
        case StepFirstReview:<span class="cov8" title="1">
                return 3</span>
        case StepImplementSecondTry:<span class="cov8" title="1">
                return 4</span>
        case StepSecondReview:<span class="cov8" title="1">
                return 5</span>
        case StepImplementThirdTry:<span class="cov8" title="1">
                return 6</span>
        case StepThirdReview:<span class="cov8" title="1">
                return 7</span>
        case StepReviewerForceImplement:<span class="cov8" title="1">
                return 8</span>
        case StepImplementerReview:<span class="cov8" title="1">
                return 9</span>
        case StepDone:<span class="cov8" title="1">
                return 10</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

// ToStatus converts the step to its corresponding status
func (s ExecutionStep) ToStatus() ExecutionStatus <span class="cov8" title="1">{
        switch s </span>{
        case StepReady:<span class="cov8" title="1">
                return StatusReady</span>
        case StepImplementTry, StepImplementSecondTry, StepImplementThirdTry:<span class="cov8" title="1">
                return StatusWIP</span>
        case StepFirstReview, StepSecondReview, StepThirdReview, StepImplementerReview:<span class="cov8" title="1">
                return StatusReview</span>
        case StepReviewerForceImplement:<span class="cov8" title="1">
                return StatusReviewAndWIP</span> // Special status for dual role
        case StepDone:<span class="cov8" title="1">
                return StatusDone</span>
        default:<span class="cov8" title="1">
                return StatusUnknown</span>
        }
}

// IsImplementation returns true if this is an implementation step
func (s ExecutionStep) IsImplementation() bool <span class="cov8" title="1">{
        return s == StepImplementTry ||
                s == StepImplementSecondTry ||
                s == StepImplementThirdTry ||
                s == StepReviewerForceImplement
}</span>

// IsReview returns true if this is a review step
func (s ExecutionStep) IsReview() bool <span class="cov8" title="1">{
        return s == StepFirstReview ||
                s == StepSecondReview ||
                s == StepThirdReview ||
                s == StepImplementerReview ||
                s == StepReviewerForceImplement // Has review component
}</span>

// CanTransitionTo validates if transition to the next step is allowed
func (s ExecutionStep) CanTransitionTo(next ExecutionStep) bool <span class="cov8" title="1">{
        validTransitions := map[ExecutionStep][]ExecutionStep{
                StepReady:                  {StepImplementTry},
                StepImplementTry:           {StepFirstReview},
                StepFirstReview:            {StepImplementSecondTry, StepDone},
                StepImplementSecondTry:     {StepSecondReview},
                StepSecondReview:           {StepImplementThirdTry, StepDone},
                StepImplementThirdTry:      {StepThirdReview},
                StepThirdReview:            {StepReviewerForceImplement, StepDone},
                StepReviewerForceImplement: {StepImplementerReview},
                StepImplementerReview:      {StepDone},
                StepDone:                   {}, // No transitions from done
        }

        allowed, exists := validTransitions[s]
        if !exists </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, validNext := range allowed </span><span class="cov8" title="1">{
                if validNext == next </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// GetAttemptNumber returns the attempt number for implementation steps
func (s ExecutionStep) GetAttemptNumber() int <span class="cov8" title="1">{
        switch s </span>{
        case StepImplementTry:<span class="cov8" title="1">
                return 1</span>
        case StepImplementSecondTry:<span class="cov8" title="1">
                return 2</span>
        case StepImplementThirdTry:<span class="cov8" title="1">
                return 3</span>
        case StepReviewerForceImplement:<span class="cov8" title="1">
                return 4</span> // Special forced implementation
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

// IsValid returns true if the step is a valid execution step
func (s ExecutionStep) IsValid() bool <span class="cov8" title="1">{
        switch s </span>{
        case StepReady, StepImplementTry, StepFirstReview,
                StepImplementSecondTry, StepSecondReview,
                StepImplementThirdTry, StepThirdReview,
                StepReviewerForceImplement, StepImplementerReview,
                StepDone:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package execution

import (
        "fmt"
)

// ExecutionService provides domain services for SBI execution
type ExecutionService struct {
        repository SBIExecutionRepository
}

// NewExecutionService creates a new execution service
func NewExecutionService(repo SBIExecutionRepository) *ExecutionService <span class="cov8" title="1">{
        return &amp;ExecutionService{
                repository: repo,
        }
}</span>

// StartExecution starts a new SBI execution
func (s *ExecutionService) StartExecution(sbiID string) (*SBIExecution, error) <span class="cov8" title="1">{
        // Check if there's already an active execution for this SBI
        existing, err := s.repository.FindBySBIID(sbiID)
        if err == nil &amp;&amp; existing != nil &amp;&amp; !existing.IsCompleted() </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("SBI %s already has an active execution", sbiID)
        }</span>

        // Create new execution
        <span class="cov8" title="1">execution := NewSBIExecution(sbiID)

        // Save to repository
        if err := s.repository.Save(execution); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to save execution: %w", err)
        }</span>

        <span class="cov8" title="1">return execution, nil</span>
}

// ProgressExecution progresses the execution to the next step
func (s *ExecutionService) ProgressExecution(executionID ExecutionID, decision Decision) (*SBIExecution, error) <span class="cov8" title="1">{
        // Load execution
        execution, err := s.repository.FindByID(executionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("execution not found: %w", err)
        }</span>

        <span class="cov8" title="1">if execution.IsCompleted() </span><span class="cov8" title="1">{
                return execution, fmt.Errorf("execution is already completed")
        }</span>

        // Apply decision if in review status
        <span class="cov8" title="1">if execution.Status.IsReview() &amp;&amp; decision.IsValid() &amp;&amp; !decision.IsPending() </span><span class="cov8" title="1">{
                if err := execution.ApplyDecision(decision); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply decision: %w", err)
                }</span>
        }

        // Determine next step
        <span class="cov8" title="1">nextStep, err := execution.NextStep()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to determine next step: %w", err)
        }</span>

        // Transition to next step
        <span class="cov8" title="1">if err := execution.TransitionTo(nextStep); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to transition: %w", err)
        }</span>

        // Check for force termination
        <span class="cov8" title="1">if execution.ShouldForceTerminate() &amp;&amp; nextStep != StepDone </span><span class="cov8" title="1">{
                // Force transition to termination path
                nextStep = StepReviewerForceImplement
                if err := execution.TransitionTo(nextStep); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to force terminate: %w", err)
                }</span>
        }

        // Update in repository
        <span class="cov8" title="1">if err := s.repository.Update(execution); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to update execution: %w", err)
        }</span>

        <span class="cov8" title="1">return execution, nil</span>
}

// GetExecutionPath returns the execution path for an SBI
func (s *ExecutionService) GetExecutionPath(executionID ExecutionID) ([]ExecutionStep, error) <span class="cov8" title="1">{
        execution, err := s.repository.FindByID(executionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("execution not found: %w", err)
        }</span>

        // Build the path based on the current step and decision history
        <span class="cov8" title="1">path := []ExecutionStep{StepReady}

        // Always includes first implementation and review
        path = append(path, StepImplementTry, StepFirstReview)

        // Determine the rest based on attempt number and decisions
        if execution.Step.ToNumber() &lt;= 3 &amp;&amp; execution.Decision == DecisionSucceeded </span><span class="cov0" title="0">{
                // Early success
                path = append(path, StepDone)
                return path, nil
        }</span>

        // Second attempt
        <span class="cov8" title="1">if execution.Step.ToNumber() &gt;= 4 </span><span class="cov8" title="1">{
                path = append(path, StepImplementSecondTry, StepSecondReview)
        }</span>

        <span class="cov8" title="1">if execution.Step.ToNumber() &lt;= 5 &amp;&amp; execution.Step == StepDone </span><span class="cov0" title="0">{
                // Second attempt success
                path = append(path, StepDone)
                return path, nil
        }</span>

        // Third attempt
        <span class="cov8" title="1">if execution.Step.ToNumber() &gt;= 6 </span><span class="cov8" title="1">{
                path = append(path, StepImplementThirdTry, StepThirdReview)
        }</span>

        <span class="cov8" title="1">if execution.Step.ToNumber() &lt;= 7 &amp;&amp; execution.Step == StepDone </span><span class="cov0" title="0">{
                // Third attempt success
                path = append(path, StepDone)
                return path, nil
        }</span>

        // Force termination path
        <span class="cov8" title="1">if execution.Step.ToNumber() &gt;= 8 </span><span class="cov8" title="1">{
                path = append(path, StepReviewerForceImplement, StepImplementerReview, StepDone)
        }</span>

        <span class="cov8" title="1">return path, nil</span>
}

// CompleteExecution marks an execution as completed
func (s *ExecutionService) CompleteExecution(executionID ExecutionID, finalDecision Decision) error <span class="cov8" title="1">{
        execution, err := s.repository.FindByID(executionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("execution not found: %w", err)
        }</span>

        <span class="cov8" title="1">if execution.IsCompleted() </span><span class="cov8" title="1">{
                return fmt.Errorf("execution is already completed")
        }</span>

        // Apply final decision
        <span class="cov8" title="1">execution.Decision = finalDecision

        // Transition to done
        if err := execution.TransitionTo(StepDone); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to complete execution: %w", err)
        }</span>

        // Update in repository
        <span class="cov8" title="1">if err := s.repository.Update(execution); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to update execution: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetActiveExecutions returns all active executions
func (s *ExecutionService) GetActiveExecutions() ([]*SBIExecution, error) <span class="cov8" title="1">{
        return s.repository.FindActive()
}</span>

// IsExecutionStuck checks if an execution is stuck and needs intervention
func (s *ExecutionService) IsExecutionStuck(executionID ExecutionID) (bool, string) <span class="cov8" title="1">{
        execution, err := s.repository.FindByID(executionID)
        if err != nil </span><span class="cov8" title="1">{
                return false, ""
        }</span>

        // Check if stuck in review with multiple failures
        <span class="cov8" title="1">if execution.Status == StatusReview &amp;&amp;
                execution.Decision == DecisionNeedsChanges &amp;&amp;
                execution.Attempt &gt;= 3 </span><span class="cov8" title="1">{
                return true, "Multiple review failures, consider force termination"
        }</span>

        // Check if stuck in implementation for too long
        <span class="cov8" title="1">if execution.Status == StatusWIP &amp;&amp; execution.Attempt &gt; 3 </span><span class="cov8" title="1">{
                return true, "Too many implementation attempts"
        }</span>

        <span class="cov8" title="1">return false, ""</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
