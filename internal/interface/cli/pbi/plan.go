package pbi

import (
	"database/sql"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/YoshitsuguKoike/deespec/internal/application/usecase/pbi"
	pbidomain "github.com/YoshitsuguKoike/deespec/internal/domain/model/pbi"
	"github.com/YoshitsuguKoike/deespec/internal/infra/config"
	"github.com/YoshitsuguKoike/deespec/internal/infrastructure/parser"
	"github.com/YoshitsuguKoike/deespec/internal/infrastructure/persistence"
	"github.com/YoshitsuguKoike/deespec/internal/infrastructure/persistence/sqlite"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
)

// NewPlanCommand creates a new plan command
func NewPlanCommand() *cobra.Command {
	var (
		filePath    string
		title       string
		storyPoints int
		priority    int
		status      string
	)

	cmd := &cobra.Command{
		Use:   "plan",
		Short: "Plan a new PBI (Product Backlog Item)",
		Long: `Plan a Product Backlog Item (PBI) in two ways:
1. Interactive mode (default)
2. From Markdown file

The PBI ID is automatically generated by the system.
Markdown file is stored at .deespec/specs/pbi/{id}/pbi.md

After planning, use 'deespec pbi decompose' to break down the PBI into SBIs.`,
		Example: `  # Interactive mode
  deespec pbi plan

  # From Markdown file
  deespec pbi plan -f docs/plan.md

  # From file with overrides
  deespec pbi plan -f docs/plan.md \
    -t "Custom Title" \
    --story-points 8 \
    --priority 1 \
    --status planning`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runPlan(filePath, title, storyPoints, priority, status)
		},
	}

	cmd.Flags().StringVarP(&filePath, "file", "f", "", "Load from Markdown file")
	cmd.Flags().StringVarP(&title, "title", "t", "", "Override title")
	cmd.Flags().IntVarP(&storyPoints, "story-points", "s", -1, "Override story points (0-13)")
	cmd.Flags().IntVarP(&priority, "priority", "p", -1, "Override priority (0=é€šå¸¸, 1=é«˜, 2=ç·Šæ€¥)")
	cmd.Flags().StringVar(&status, "status", "", "Override status (pending|planning|planed|in_progress|done)")

	return cmd
}

func runPlan(filePath, titleOverride string, storyPoints, priority int, status string) error {
	// Load settings
	rootPath, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get working directory: %w", err)
	}
	cfg, err := config.LoadSettings(rootPath)
	if err != nil {
		return fmt.Errorf("failed to load settings: %w", err)
	}

	// Open database
	db, err := sql.Open("sqlite3", ".deespec/deespec.db")
	if err != nil {
		return fmt.Errorf("failed to open database: %w", err)
	}
	defer db.Close()

	// Run migrations first
	migrator := sqlite.NewMigrator(db)
	if err := migrator.Migrate(); err != nil {
		return fmt.Errorf("failed to run migrations: %w", err)
	}

	// Create repository
	repo := persistence.NewPBISQLiteRepository(db, rootPath)

	// Create use case
	useCase := pbi.NewRegisterPBIUseCase(repo)

	var p *pbidomain.PBI
	var body string

	if filePath != "" {
		// File mode
		p, body, err = loadFromFile(filePath, titleOverride)
		if err != nil {
			return err
		}
	} else {
		// Interactive mode
		p, body, err = runInteractive(cfg.Editor())
		if err != nil {
			return err
		}
	}

	// Apply overrides if specified
	if storyPoints >= 0 {
		if storyPoints > 13 {
			return fmt.Errorf("story points must be between 0 and 13, got %d", storyPoints)
		}
		p.EstimatedStoryPoints = storyPoints
	}

	if priority >= 0 {
		if priority > 2 {
			return fmt.Errorf("priority must be 0 (é€šå¸¸), 1 (é«˜), or 2 (ç·Šæ€¥), got %d", priority)
		}
		p.Priority = pbidomain.Priority(priority)
	}

	if status != "" {
		validStatuses := []string{"pending", "planning", "planed", "in_progress", "done"}
		isValid := false
		for _, validStatus := range validStatuses {
			if status == validStatus {
				isValid = true
				break
			}
		}
		if !isValid {
			return fmt.Errorf("invalid status: %s (valid: pending, planning, planed, in_progress, done)", status)
		}
		p.Status = pbidomain.Status(status)
	}

	// Execute use case
	pbiID, err := useCase.Execute(p, body)
	if err != nil {
		return fmt.Errorf("failed to plan PBI: %w", err)
	}

	fmt.Printf("âœ… PBI planned: %s\n", pbiID)
	fmt.Printf("\nView details: deespec pbi show %s\n", pbiID)
	fmt.Printf("Markdown file: %s\n", p.GetMarkdownPath())
	fmt.Printf("\nNext step: deespec pbi decompose %s\n", pbiID)

	return nil
}

func loadFromFile(filePath, titleOverride string) (*pbidomain.PBI, string, error) {
	// Read Markdown file
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, "", fmt.Errorf("failed to read file %s: %w", filePath, err)
	}

	body := string(data)

	// Extract title from H1 (allow empty)
	title, _ := parser.ExtractTitle(body)

	// Override title if specified
	if titleOverride != "" {
		title = titleOverride
	}

	// Create PBI (title can be empty, will be set to ID in use case)
	p := pbidomain.NewPBI(title)

	return p, body, nil
}

func runInteractive(editor string) (*pbidomain.PBI, string, error) {
	fmt.Println("ğŸ¯ PBI Planning Wizard")
	fmt.Println()

	// Get title (optional - will use PBI-ID if empty)
	prompt := promptui.Prompt{
		Label:   "ğŸ“ Title (optional, press Enter to use PBI-ID)",
		Default: "",
	}
	title, err := prompt.Run()
	if err != nil {
		return nil, "", fmt.Errorf("failed to read title: %w", err)
	}

	// Get description using editor
	fmt.Println("ğŸ“‹ Opening editor for description...")
	description, err := openEditor(editor, title)
	if err != nil {
		return nil, "", fmt.Errorf("failed to open editor: %w", err)
	}

	// Check if description is empty
	if description == "" {
		return nil, "", fmt.Errorf("description cannot be empty")
	}

	// Create PBI (title can be empty, will be set to ID in use case)
	p := pbidomain.NewPBI(title)

	// Create Markdown body
	if title != "" {
		body := fmt.Sprintf("# %s\n\n%s", title, description)
		fmt.Println()
		fmt.Printf("ğŸ“¦ Ready to plan PBI with title: %s\n", title)
		return p, body, nil
	} else {
		// Title will be set to PBI-ID in use case
		body := description
		fmt.Println()
		fmt.Printf("ğŸ“¦ Ready to plan PBI (title will be set to PBI-ID)\n")
		return p, body, nil
	}
}

// openEditor opens the default editor for user input
func openEditor(configuredEditor, initialTitle string) (string, error) {
	// Determine editor to use (config setting is already determined by settings.go)
	editor := configuredEditor
	if editor == "" {
		return "", fmt.Errorf("no editor configured. Please set 'editor' in setting.json or $EDITOR environment variable")
	}

	// Create temporary file
	tmpDir := os.TempDir()
	tmpFile := filepath.Join(tmpDir, "deespec-pbi-*.md")
	f, err := os.CreateTemp(tmpDir, "deespec-pbi-*.md")
	if err != nil {
		return "", fmt.Errorf("failed to create temporary file: %w", err)
	}
	tmpFile = f.Name()
	defer os.Remove(tmpFile)

	// Write initial content
	initialContent := "# Write your PBI description here\n\n"
	if initialTitle != "" {
		initialContent = fmt.Sprintf("# %s\n\n", initialTitle)
	}
	initialContent += "# Lines starting with '#' are comments and will be removed.\n"
	if _, err := f.WriteString(initialContent); err != nil {
		f.Close()
		return "", fmt.Errorf("failed to write to temporary file: %w", err)
	}
	f.Close()

	// Open editor
	cmd := exec.Command(editor, tmpFile)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("editor exited with error: %w", err)
	}

	// Read content
	content, err := os.ReadFile(tmpFile)
	if err != nil {
		return "", fmt.Errorf("failed to read temporary file: %w", err)
	}

	// Remove comment lines
	lines := []string{}
	for _, line := range splitLines(string(content)) {
		if len(line) > 0 && line[0] != '#' {
			lines = append(lines, line)
		}
	}

	result := ""
	for i, line := range lines {
		if i > 0 {
			result += "\n"
		}
		result += line
	}

	// Trim whitespace
	result = trimWhitespace(result)

	return result, nil
}
